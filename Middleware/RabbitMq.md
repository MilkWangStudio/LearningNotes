# RabbitMq
## 优缺点
优点：
- 异步处理：提高吞吐量
- 应用解耦：通过消息通信，不关心其他系统处理
- 流量削峰：通过消息队列控制请求量，缓解短时间的高并发请求

缺点：
- 降低系统可用性
- 提高系统复杂度
- 出现数据一致性问题

## RabbitMq如何保证消息不丢失
先说明可能会导致消息丢失的几种场景。
1. 发送者到RabbitMq
2. Broker节点重启、宕机，消息丢失
3. 消费者接收消息后宕机，丢失

### 机制1：发送确认机制
生产者把信道设置为confirm 确认模式，所有在该信道发布的消息都会被指定一个唯一ID，一旦被投递到所匹配的队列后，RabbitMQ会发送一个确认（Basic.Ack）给生产者，这样生产者就知道消息到达对应的目的地了。

### 机制2：消息持久化
RabbitMq消息默认配置是存储在内存里，不特别声明时，消息不会持久化到硬盘上，节点重启就丢失了。

要做到消息持久化，必须满足一下三个条件
- Exchange设置持久化
- Queue设置持久化
- Message持久化返送：发送时设置deliveryMode=2，代表持久化消息

### 机制3：ACK确认机制
默认ack及时开启的，但是Consumer又默认是自动提交确认，需要改成手动。

ack是指消费者消费完成后，响应给Broker一个ack消息，Broker收到后才会将Message删除，如果消费者宕机的话，超时后其他Consumer可以继续消费。

### 机制4：设置集群镜像模式
- 普通模式：默认的集群模式，某个节点挂了，该节点上的消息无法消费，导致受影响的业务瘫痪
- 镜像模式：把需要的队列做成“镜像队列”，存在于多个节点，本质是一个HA方案

镜像模式的HA策略有三种：
- 同步至所有节点
- 同步最多N个机器
- 只同步至符合指定名称的nodes

### 机制5：消息补偿机制
这个主要是一些极端情况，比如Broker这个机器直接挂了，磁盘也坏了。  
另外就是一些业务问题，比如处理错误需要重新消费等。

这个本质上不是RabbitMq提供的功能，我们需要将消息的发送、接收两者的日志都记录下来，包括状态变化，业务是否处理完成等，后续才能进行补偿操作。  
而且一般补偿操作也是我们特殊开发代码来处理，不是原消息重发。  

下面是一个消息补偿逻辑的交互图：

![resender](./static/RabbitMq-resender.png)
